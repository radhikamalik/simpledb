package simpledb;

import java.util.NoSuchElementException;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {

	JoinPredicate p;
	DbIterator child1;
	DbIterator child2;
	private Tuple next1 = null;

	// private Tuple next2 = null;

	/**
	 * Constructor. Accepts to children to join and the predicate to join them
	 * on
	 * 
	 * @param p
	 *            The predicate to use to join the children
	 * @param child1
	 *            Iterator for the left(outer) relation to join
	 * @param child2
	 *            Iterator for the right(inner) relation to join
	 */
	public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
		this.p = p;
		this.child1 = child1;
		this.child2 = child2;
	}

	/**
	 * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
	 *      implementation logic.
	 */
	public TupleDesc getTupleDesc() {
		TupleDesc t1 = child1.getTupleDesc();
		TupleDesc t2 = child2.getTupleDesc();
		return TupleDesc.merge(t1, t2);
	}

	public void open() throws DbException, NoSuchElementException,
			TransactionAbortedException {
		child1.open();
		child2.open();
	}

	public void close() {
		child1.close();
		child2.close();
	}

	public void rewind() throws DbException, TransactionAbortedException {
		child1.rewind();
		child2.rewind();
	}

	/**
	 * Returns the next tuple generated by the join, or null if there are no
	 * more tuples. Logically, this is the next tuple in r1 cross r2 that
	 * satisfies the join predicate. There are many possible implementations;
	 * the simplest is a nested loops join.
	 * <p>
	 * Note that the tuples returned from this particular implementation of Join
	 * are simply the concatenation of joining tuples from the left and right
	 * relation. Therefore, if an equality predicate is used there will be two
	 * copies of the join attribute in the results. (Removing such duplicate
	 * columns can be done with an additional projection operator if needed.)
	 * <p>
	 * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
	 * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
	 * 
	 * @return The next matching tuple.
	 * @see JoinPredicate#filter
	 */
	protected Tuple fetchNext() throws TransactionAbortedException, DbException {

		if (next1 == null && !child1.hasNext() && !child2.hasNext())
			return null;

		if (next1 == null && child1.hasNext())
			next1 = child1.next();

		if (next1 != null && !child2.hasNext()) {
			if (!child1.hasNext())
				return null;

			next1 = child1.next();
			child2.rewind();
		}

		while (next1 != null && child2.hasNext()) {
			Tuple next2 = child2.next();
			if (p.filter(next1, next2)) {
				Tuple result = new Tuple(TupleDesc.merge(next1.getTupleDesc(),
						next2.getTupleDesc()));

				int numFields = next1.getTupleDesc().numFields();
				for (int i = 0; i < numFields; i++)
					result.setField(i, next1.getField(i));

				for (int j = 0; j < next2.getTupleDesc().numFields(); j++)
					result.setField(j + numFields, next2.getField(j));

				return result;
			}

			if (!child2.hasNext()) {
				if (!child1.hasNext())
					return null;

				next1 = child1.next();
				child2.rewind();
			}
		}
		return null;
	}

}
